TODO: turn fusion on (need to adapt SimplifyTransform)
----- Sym(26) / Set((re,Sym(27)), (im,Sym(28)))
TTP(List(Sym(8)),ThinDef(Minus(Const(0.0),Sym(7))))
TTP(List(Sym(10)),SimpleFatLoop(Const(100),Sym(7),List(ArrayElem(Sym(8)))))
TTP(List(Sym(13)),ThinDef(Reflect(NewVar(Sym(10)),Summary(false,false,false,false,true,List(),List(),List(),List()),List())))
TTP(List(Sym(11)),SimpleFatLoop(Const(100),Sym(7),List(ArrayElem(Sym(7)))))
TTP(List(Sym(14)),ThinDef(Reflect(NewVar(Sym(11)),Summary(false,false,false,false,true,List(),List(),List(),List()),List())))
TTP(List(Sym(16)),ThinDef(OrderingGT(Sym(0),Const(7))))
TTP(List(Sym(17)),ThinDef(Reflect(Print(Const(foobar true)),Summary(true,true,false,false,false,List(),List(),List(),List()),List())))
TTP(List(Sym(24)),ThinDef(Reify(Const(()),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(17)))))
TTP(List(Sym(19)),ThinDef(Reflect(Print(Const(foobar false)),Summary(true,true,false,false,false,List(),List(),List(),List()),List())))
TTP(List(Sym(20)),ThinDef(Reflect(ReadVar(Variable(Sym(13))),Summary(false,false,false,false,false,List(Sym(13)),List(Sym(13)),List(),List()),List(Sym(13)))))
TTP(List(Sym(21)),ThinDef(Reflect(ReadVar(Variable(Sym(14))),Summary(false,false,false,false,false,List(Sym(14)),List(Sym(14)),List(),List()),List(Sym(14)))))
TTP(List(Sym(25)),ThinDef(Reify(Const(()),Summary(true,true,false,false,false,List(Sym(13), Sym(14)),List(Sym(13), Sym(14)),List(),List()),List(Sym(19), Sym(20), Sym(21)))))
TTP(List(Sym(26), Sym(27), Sym(28)),SimpleFatIf(Sym(16),List(Sym(24), Sym(4), Sym(5)),List(Sym(25), Sym(20), Sym(21))))
TTP(List(Sym(4)),SimpleFatLoop(Const(100),Sym(1),List(ArrayElem(Sym(1)))))
TTP(List(Sym(30)),ThinDef(Reflect(Assign(Variable(Sym(13)),Sym(4)),Summary(false,false,false,false,false,List(Sym(13)),List(Sym(13)),List(Sym(13)),List(Sym(13))),List(Sym(13), Sym(26)))))
TTP(List(Sym(2)),ThinDef(Minus(Const(0.0),Sym(1))))
TTP(List(Sym(5)),SimpleFatLoop(Const(100),Sym(1),List(ArrayElem(Sym(2)))))
TTP(List(Sym(31)),ThinDef(Reflect(Assign(Variable(Sym(14)),Sym(5)),Summary(false,false,false,false,false,List(Sym(14)),List(Sym(14)),List(Sym(14)),List(Sym(14))),List(Sym(14), Sym(26)))))
TTP(List(Sym(32)),ThinDef(Reflect(ReadVar(Variable(Sym(13))),Summary(false,false,false,false,false,List(Sym(13)),List(Sym(13)),List(),List()),List(Sym(13), Sym(30)))))
TTP(List(Sym(33)),ThinDef(Reflect(ReadVar(Variable(Sym(14))),Summary(false,false,false,false,false,List(Sym(14)),List(Sym(14)),List(),List()),List(Sym(14), Sym(31)))))
TTP(List(Sym(34)),ThinDef(Struct(List(Array, Complex),Map(re -> Sym(32), im -> Sym(33)))))
TTP(List(Sym(35)),ThinDef(Reflect(Print(Sym(34)),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(26)))))
TTP(List(Sym(29)),ThinDef(Struct(List(Array, Complex),Map(re -> Sym(27), im -> Sym(28)))))
TTP(List(Sym(36)),ThinDef(Reflect(Print(Sym(29)),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(26), Sym(35)))))
TTP(List(Sym(37)),ThinDef(Reify(Sym(36),Summary(true,true,false,false,false,List(Sym(13), Sym(14)),List(Sym(13), Sym(14)),List(Sym(13), Sym(14)),List(Sym(13), Sym(14))),List(Sym(13), Sym(14), Sym(26), Sym(30), Sym(31), Sym(32), Sym(33), Sym(35), Sym(36)))))
TTP(List(Sym(8)),ThinDef(Minus(Const(0.0),Sym(7))))
TTP(List(Sym(2)),ThinDef(Minus(Const(0.0),Sym(1))))
TTP(List(Sym(17)),ThinDef(Reflect(Print(Const(foobar true)),Summary(true,true,false,false,false,List(),List(),List(),List()),List())))
TTP(List(Sym(24)),ThinDef(Reify(Const(()),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(17)))))
TTP(List(Sym(20)),ThinDef(Reflect(ReadVar(Variable(Sym(13))),Summary(false,false,false,false,false,List(Sym(13)),List(Sym(13)),List(),List()),List(Sym(13)))))
TTP(List(Sym(21)),ThinDef(Reflect(ReadVar(Variable(Sym(14))),Summary(false,false,false,false,false,List(Sym(14)),List(Sym(14)),List(),List()),List(Sym(14)))))
TTP(List(Sym(19)),ThinDef(Reflect(Print(Const(foobar false)),Summary(true,true,false,false,false,List(),List(),List(),List()),List())))
TTP(List(Sym(25)),ThinDef(Reify(Const(()),Summary(true,true,false,false,false,List(Sym(13), Sym(14)),List(Sym(13), Sym(14)),List(),List()),List(Sym(19), Sym(20), Sym(21)))))
error: violated ordering of effects
  expected:
    TTP(List(Sym(19)),ThinDef(Reflect(Print(Const(foobar false)),Summary(true,true,false,false,false,List(),List(),List(),List()),List())))
    TTP(List(Sym(20)),ThinDef(Reflect(ReadVar(Variable(Sym(13))),Summary(false,false,false,false,false,List(Sym(13)),List(Sym(13)),List(),List()),List(Sym(13)))))
    TTP(List(Sym(21)),ThinDef(Reflect(ReadVar(Variable(Sym(14))),Summary(false,false,false,false,false,List(Sym(14)),List(Sym(14)),List(),List()),List(Sym(14)))))
  actual:
    TTP(List(Sym(20)),ThinDef(Reflect(ReadVar(Variable(Sym(13))),Summary(false,false,false,false,false,List(Sym(13)),List(Sym(13)),List(),List()),List(Sym(13)))))
    TTP(List(Sym(21)),ThinDef(Reflect(ReadVar(Variable(Sym(14))),Summary(false,false,false,false,false,List(Sym(14)),List(Sym(14)),List(),List()),List(Sym(14)))))
    TTP(List(Sym(19)),ThinDef(Reflect(Print(Const(foobar false)),Summary(true,true,false,false,false,List(),List(),List(),List()),List())))
  missing:
  note: there is nothing missing so the different order might in fact be ok (artifact of new effect handling? TODO)
/*****************************************
  Emitting Generated Code                  
*******************************************/
class Test extends ((Int)=>(Any)) {
def apply(x0:Int): Any = {
var x10 = new Array[](100)
for (x7 <- 0 until 100) {
val x8 = 0.0-x7
x10(x7) = x8
}
var x13: Any = x10
var x11 = new Array[](100)
for (x7 <- 0 until 100) {
x11(x7) = x7
}
var x14: Any = x11
val x16 = x0 > 7
var x4 = new Array[](100)
for (x1 <- 0 until 100) {
x4(x1) = x1
}
var x5 = new Array[](100)
for (x1 <- 0 until 100) {
val x2 = 0.0-x1
x5(x1) = x2
}
val (x26,x27,x28) = if (x16) {
val x17 = println("foobar true")
((),x4,x5)
} else {
val x20 = x13
val x21 = x14
val x19 = println("foobar false")
((),x20,x21)
}
x13 = x4
x14 = x5
val x32 = x13
val x33 = x14
val x34 = XXX Struct(List(Array, Complex),Map(re -> Sym(32), im -> Sym(33)))
val x35 = println(x34)
val x29 = XXX Struct(List(Array, Complex),Map(re -> Sym(27), im -> Sym(28)))
val x36 = println(x29)
x36
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
