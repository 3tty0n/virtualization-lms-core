-- full graph
TP(Sym(3),SimpleLoop(Const(50),Sym(2),ArrayElem(Block(Const(1.0)))))
TP(Sym(4),SimpleLoop(Const(100),Sym(1),ArrayElem(Block(Sym(3)))))
TP(Sym(7),SimpleLoop(Const(50),Sym(6),ArrayElem(Block(Const(2.0)))))
TP(Sym(8),SimpleLoop(Const(100),Sym(5),ArrayElem(Block(Sym(7)))))
TP(Sym(11),SimpleLoop(Const(50),Sym(10),ReduceElem(Block(Const(4.0)))))
TP(Sym(12),SimpleLoop(Const(100),Sym(9),ArrayElem(Block(Sym(11)))))
TP(Sym(15),ArrayIndex(Sym(4),Sym(13)))
TP(Sym(16),ArrayIndex(Sym(15),Sym(14)))
TP(Sym(17),ArrayIndex(Sym(8),Sym(13)))
TP(Sym(18),ArrayIndex(Sym(17),Sym(14)))
TP(Sym(19),Plus(Sym(16),Sym(18)))
TP(Sym(20),SimpleLoop(Const(50),Sym(14),ReduceElem(Block(Sym(19)))))
TP(Sym(21),ArrayIndex(Sym(12),Sym(13)))
TP(Sym(22),Plus(Sym(20),Sym(21)))
TP(Sym(23),SimpleLoop(Const(100),Sym(13),ArrayElem(Block(Sym(22)))))
TP(Sym(24),Reflect(Print(Sym(4)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(25),Reflect(Print(Sym(8)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(24))))
TP(Sym(26),Reflect(Print(Sym(12)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(25))))
TP(Sym(27),Reflect(Print(Sym(23)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(26))))
TP(Sym(28),Reify(Sym(27),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(24), Sym(25), Sym(26), Sym(27))))

-- before transformation
var x3 = new Array[Double](50)
for (x2 <- 0 until 50) {
x3(x2) = 1.0
}
var x4 = new Array[Array[Double]](100)
for (x1 <- 0 until 100) {
x4(x1) = x3
}
val x24 = println(x4)
var x7 = new Array[Double](50)
for (x6 <- 0 until 50) {
x7(x6) = 2.0
}
var x8 = new Array[Array[Double]](100)
for (x5 <- 0 until 100) {
x8(x5) = x7
}
val x25 = println(x8)
var x11 = 0
for (x10 <- 0 until 50) {
x11 += 4.0
}
var x12 = new Array[Double](100)
for (x9 <- 0 until 100) {
x12(x9) = x11
}
val x26 = println(x12)
var x23 = new Array[Double](100)
for (x13 <- 0 until 100) {
val x15 = x4.apply(x13)
val x17 = x8.apply(x13)
var x20 = 0
for (x14 <- 0 until 50) {
val x16 = x15.apply(x14)
val x18 = x17.apply(x14)
val x19 = x16+x18
x20 += x19
}
val x21 = x12.apply(x13)
val x22 = x20+x21
x23(x13) = x22
}
val x27 = println(x23)

-- vertical transformation

(VFT) No producers found for TP(Sym(3),SimpleLoop(Const(50),Sym(2),ArrayElem(Block(Const(1.0)))))

(VFT) No producers found for TP(Sym(4),SimpleLoop(Const(100),Sym(1),ArrayElem(Block(Sym(3)))))

(VFT) No producers found for TP(Sym(7),SimpleLoop(Const(50),Sym(6),ArrayElem(Block(Const(2.0))))), remapping to Sym(29) because of fixed shape

(VFT) No producers found for TP(Sym(8),SimpleLoop(Const(100),Sym(5),ArrayElem(Block(Sym(7))))), remapping to Sym(30) because of fixed shape

(VFT) No producers found for TP(Sym(11),SimpleLoop(Const(50),Sym(10),ReduceElem(Block(Const(4.0)))))

(VFT) No producers found for TP(Sym(12),SimpleLoop(Const(100),Sym(9),ArrayElem(Block(Sym(11))))), remapping to Sym(32) because of fixed shape

(VFT) Fusing consumer TP(Sym(23),SimpleLoop(Const(100),Sym(13),ArrayElem(Block(Sym(22))))) with reconstructed producer: Sym(4) and then with: List(Sym(30) (was Sym(8)), Sym(32) (was Sym(12)))
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(3).
(VFT) SimpleCollect+Any fusion: nothing more to do for first producer, fuse with other producers: List(Sym(30), Sym(32))
(VFT) Multiple fusion: remap SimpleIndex(Sym(30)) to Sym(29).
(VFT) Multiple fusion: remap SimpleIndex(Sym(32)) to Sym(11).
  
  (VFT) Successive simpleIndex fusion of outer: SimpleIndex(Sym(15), Sym(14)) where inner has already been fused: TP(Sym(15),ArrayIndex(Sym(4),Sym(13))) -> Sym(3)
  (VFT) Successive simpleIndex fusion of outer: SimpleIndex(Sym(17), Sym(14)) where inner has already been fused: TP(Sym(17),ArrayIndex(Sym(8),Sym(13))) -> Sym(29)
  (VFT) Fusing consumer TP(Sym(20),SimpleLoop(Const(50),Sym(14),ReduceElem(Block(Sym(19))))) with reconstructed producer: Sym(3) and then with: List(Sym(29))
  (VFT) General fusion: remap index to Sym(2), SimpleIndex to Const(1.0).
  (VFT) SimpleCollect+Any fusion: nothing more to do for first producer, fuse with other producers: List(Sym(29))
  (VFT) Multiple fusion: remap SimpleIndex(Sym(29)) to Const(2.0).
  
  (VFT) Finished fusion of prods: List(Sym(3), Sym(29)) and cons: Sym(20), the resulting fused loop is Sym(35)

(VFT) Finished fusion of prods: List(Sym(4), Sym(30), Sym(32)) and cons: Sym(23), the resulting fused loop is Sym(37)

(VFT) all vertically fused: List(Sym(37), Sym(30), Sym(4), Sym(32))
List(Sym(35), Sym(3), Sym(29))

-- after vertical transformation
var x3 = new Array[Double](50)
for (x2 <- 0 until 50) {
x3(x2) = 1.0
}
var x4 = new Array[Array[Double]](100)
for (x1 <- 0 until 100) {
x4(x1) = x3
}
val x24 = println(x4)
var x29 = new Array[Double](50)
for (x2 <- 0 until 50) {
x29(x2) = 2.0
}
var x30 = new Array[Array[Double]](100)
for (x1 <- 0 until 100) {
x30(x1) = x29
}
val x31 = println(x30)
var x11 = 0
for (x10 <- 0 until 50) {
x11 += 4.0
}
var x32 = new Array[Double](100)
for (x1 <- 0 until 100) {
x32(x1) = x11
}
val x33 = println(x32)
val x34 = 1.0+2.0
var x35 = 0
for (x2 <- 0 until 50) {
x35 += x34
}
val x36 = x35+x11
var x37 = new Array[Double](100)
for (x1 <- 0 until 100) {
x37(x1) = x36
}
val x38 = println(x37)

-- horizontal transformation
(HFT) Recording Sym(3), no fusion
(HFT) Recording Sym(4), no fusion
(HFT) Fusing Sym(29) with containing fusion set FusedSet(shape = Const(50), indexSym = Sym(2), loopSyms = List(Sym(35), Sym(3), Sym(29)))
(HFT) - already using same index Sym(2)
(HFT) Fusing Sym(30) with containing fusion set FusedSet(shape = Const(100), indexSym = Sym(1), loopSyms = List(Sym(37), Sym(30), Sym(4), Sym(32)))
(HFT) - already using same index Sym(1)
(HFT) Fusing Sym(11) with fusion set FusedSet(shape = Const(50), indexSym = Sym(2), loopSyms = List(Sym(35), Sym(3), Sym(29)))
(HFT) - remapping index: Sym(10) -> Sym(2)
(HFT) - new loop symbol: Sym(11) -> Sym(41)
(HFT) Fusing Sym(32) with containing fusion set FusedSet(shape = Const(100), indexSym = Sym(1), loopSyms = List(Sym(37), Sym(30), Sym(4), Sym(32)))
(HFT) - already using same index Sym(1)
(HFT) - new loop symbol: Sym(32) -> Sym(42)
(HFT) Fusing Sym(35) with containing fusion set FusedSet(shape = Const(50), indexSym = Sym(2), loopSyms = List(Sym(35), Sym(3), Sym(29), Sym(11)))
(HFT) - already using same index Sym(2)
(HFT) Fusing Sym(37) with containing fusion set FusedSet(shape = Const(100), indexSym = Sym(1), loopSyms = List(Sym(37), Sym(30), Sym(4), Sym(32)))
(HFT) - already using same index Sym(1)
(HFT) - new loop symbol: Sym(37) -> Sym(45)

(HFT) all horizontally fused: List(Sym(4), Sym(30), Sym(42), Sym(45))
List(Sym(3), Sym(29), Sym(41), Sym(35))

-- after horizontal transformation
var x3 = new Array[Double](50)
for (x2 <- 0 until 50) {
x3(x2) = 1.0
}
var x4 = new Array[Array[Double]](100)
for (x1 <- 0 until 100) {
x4(x1) = x3
}
val x24 = println(x4)
var x29 = new Array[Double](50)
for (x2 <- 0 until 50) {
x29(x2) = 2.0
}
var x30 = new Array[Array[Double]](100)
for (x1 <- 0 until 100) {
x30(x1) = x29
}
val x31 = println(x30)
var x41 = 0
for (x2 <- 0 until 50) {
x41 += 4.0
}
var x42 = new Array[Double](100)
for (x1 <- 0 until 100) {
x42(x1) = x41
}
val x43 = println(x42)
val x34 = 1.0+2.0
var x35 = 0
for (x2 <- 0 until 50) {
x35 += x34
}
val x44 = x35+x41
var x45 = new Array[Double](100)
for (x1 <- 0 until 100) {
x45(x1) = x44
}
val x46 = println(x45)

-- fusion
(FTO) Fusing these loops into one fat TTP: 
TTP(List(Sym(4)),List(SimpleLoop(Const(100),Sym(1),ArrayElem(Block(Sym(3))))),SimpleFatLoop(Const(100),Sym(1),List(ArrayElem(Block(Sym(3))))))
TTP(List(Sym(30)),List(SimpleLoop(Const(100),Sym(1),ArrayElem(Block(Sym(29))))),SimpleFatLoop(Const(100),Sym(1),List(ArrayElem(Block(Sym(29))))))
TTP(List(Sym(42)),List(SimpleLoop(Const(100),Sym(1),ArrayElem(Block(Sym(41))))),SimpleFatLoop(Const(100),Sym(1),List(ArrayElem(Block(Sym(41))))))
TTP(List(Sym(45)),List(SimpleLoop(Const(100),Sym(1),ArrayElem(Block(Sym(44))))),SimpleFatLoop(Const(100),Sym(1),List(ArrayElem(Block(Sym(44))))))

(FTO) Fusing these loops into one fat TTP: 
TTP(List(Sym(3)),List(SimpleLoop(Const(50),Sym(2),ArrayElem(Block(Const(1.0))))),SimpleFatLoop(Const(50),Sym(2),List(ArrayElem(Block(Const(1.0))))))
TTP(List(Sym(29)),List(SimpleLoop(Const(50),Sym(2),ArrayElem(Block(Const(2.0))))),SimpleFatLoop(Const(50),Sym(2),List(ArrayElem(Block(Const(2.0))))))
TTP(List(Sym(41)),List(SimpleLoop(Const(50),Sym(2),ReduceElem(Block(Const(4.0))))),SimpleFatLoop(Const(50),Sym(2),List(ReduceElem(Block(Const(4.0))))))
TTP(List(Sym(35)),List(SimpleLoop(Const(50),Sym(2),ReduceElem(Block(Sym(34))))),SimpleFatLoop(Const(50),Sym(2),List(ReduceElem(Block(Sym(34))))))

val x34 = 1.0+2.0
var x3 = new Array[Double](50)
var x29 = new Array[Double](50)
var x41 = 0
var x35 = 0
for (x2 <- 0 until 50) {
x3(x2) = 1.0
x29(x2) = 2.0
x41 += 4.0
x35 += x34
}
val x44 = x35+x41
var x4 = new Array[Array[Double]](100)
var x30 = new Array[Array[Double]](100)
var x42 = new Array[Double](100)
var x45 = new Array[Double](100)
for (x1 <- 0 until 100) {
x4(x1) = x3
x30(x1) = x29
x42(x1) = x41
x45(x1) = x44
}
val x24 = println(x4)
val x31 = println(x30)
val x43 = println(x42)
val x46 = println(x45)
-- done
