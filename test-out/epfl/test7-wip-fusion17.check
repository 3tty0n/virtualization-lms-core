-- full graph
TP(Sym(2),IntPlus(Sym(1),Const(1)))
TP(Sym(3),Singleton(Block(Sym(2))))
TP(Sym(4),SimpleLoop(Sym(0),Sym(1),MultiArrayElem(Block(Sym(3)))))
TP(Sym(5),ArrayIndex(Sym(4),Const(0)))
TP(Sym(6),ArrayLength(Sym(4)))
TP(Sym(8),ArrayIndex(Sym(4),Sym(7)))
TP(Sym(9),OrderingGT(Sym(8),Const(0)))
TP(Sym(10),IntPlus(Sym(8),Sym(5)))
TP(Sym(11),Singleton(Block(Sym(10))))
TP(Sym(12),EmptyArrayInLoop(Sym(7)))
TP(Sym(13),IfThenElse(Sym(9),Block(Sym(11)),Block(Sym(12))))
TP(Sym(14),SimpleLoop(Sym(6),Sym(7),MultiArrayElem(Block(Sym(13)))))
TP(Sym(15),ArrayIndex(Sym(14),Const(0)))
TP(Sym(16),Reflect(Print(Sym(15)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(18),ArrayIndex(Sym(4),Sym(17)))
TP(Sym(19),IntPlus(Sym(18),Sym(5)))
TP(Sym(20),OrderingGT(Sym(19),Const(0)))
TP(Sym(21),Singleton(Block(Sym(17))))
TP(Sym(22),EmptyArrayInLoop(Sym(17)))
TP(Sym(23),IfThenElse(Sym(20),Block(Sym(21)),Block(Sym(22))))
TP(Sym(24),SimpleLoop(Sym(6),Sym(17),MultiArrayElem(Block(Sym(23)))))
TP(Sym(25),ArrayIndex(Sym(24),Const(0)))
TP(Sym(26),Reflect(Print(Sym(25)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(16))))
TP(Sym(27),ArrayLength(Sym(14)))
TP(Sym(29),ArrayIndex(Sym(14),Sym(28)))
TP(Sym(30),IntPlus(Sym(29),Sym(28)))
TP(Sym(31),Singleton(Block(Sym(30))))
TP(Sym(32),SimpleLoop(Sym(27),Sym(28),MultiArrayElem(Block(Sym(31)))))
TP(Sym(33),ArrayIndex(Sym(32),Const(0)))
TP(Sym(34),Reflect(Print(Sym(33)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(26))))
TP(Sym(35),Reify(Sym(34),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(16), Sym(26), Sym(34))))

-- before transformation
val x4 = new Array[Int](x0)
for (x1 <- 0 until x0) {
val x2 = x1 + 1
x4(x1) = x2
}
val x6 = x4.length
val x5 = x4.apply(0)
var x14 = new ArrayBuilder[Int]
for (x7 <- 0 until x6) {
val x8 = x4.apply(x7)
val x9 = x8 > 0
if (x9) {
val x10 = x8 + x5
x14 += x10
}
}
val x15 = x14.apply(0)
val x16 = println(x15)
var x24 = new ArrayBuilder[Int]
for (x17 <- 0 until x6) {
val x18 = x4.apply(x17)
val x19 = x18 + x5
val x20 = x19 > 0
if (x20) {
x24 += x17
}
}
val x25 = x24.apply(0)
val x26 = println(x25)
val x27 = x14.length
val x32 = new Array[Int](x27)
for (x28 <- 0 until x27) {
val x29 = x14.apply(x28)
val x30 = x29 + x28
x32(x28) = x30
}
val x33 = x32.apply(0)
val x34 = println(x33)

-- vertical transformation

(VFT) No producers found for cons Sym(4)
(VFT) Replaced TP(Sym(6),ArrayLength(Sym(4))) with fixed length: Sym(0)

(VFT) Not fused prod Sym(4) with cons Sym(14) because consumer depends on producer through Sym(4)
(VFT) No producers found for cons Sym(14)
(VFT) Cons Sym(14) not fused but mirrored to Sym(36) because of previous substitutions or effects

(VFT) Not fused prod Sym(4) with cons Sym(24) because consumer depends on producer through Sym(4)
(VFT) No producers found for cons Sym(24)
(VFT) Cons Sym(24) not fused but mirrored to Sym(39) because of previous substitutions or effects

(VFT) Not fused prod Sym(14) with cons Sym(32) because consumer uses index
(VFT) No producers found for cons Sym(32)
(VFT) Cons Sym(32) not fused but mirrored to Sym(46) because of previous substitutions or effects

(VFT) all vertically fused: 

-- after vertical transformation
val x4 = new Array[Int](x0)
for (x1 <- 0 until x0) {
val x2 = x1 + 1
x4(x1) = x2
}
val x5 = x4.apply(0)
var x36 = new ArrayBuilder[Int]
for (x7 <- 0 until x0) {
val x8 = x4.apply(x7)
val x9 = x8 > 0
if (x9) {
val x10 = x8 + x5
x36 += x10
}
}
val x37 = x36.apply(0)
val x38 = println(x37)
var x39 = new ArrayBuilder[Int]
for (x17 <- 0 until x0) {
val x18 = x4.apply(x17)
val x19 = x18 + x5
val x20 = x19 > 0
if (x20) {
x39 += x17
}
}
val x40 = x39.apply(0)
val x41 = println(x40)
val x42 = x36.length
val x46 = new Array[Int](x42)
for (x28 <- 0 until x42) {
val x43 = x36.apply(x28)
val x44 = x43 + x28
x46(x28) = x44
}
val x47 = x46.apply(0)
val x48 = println(x47)

-- horizontal transformation
(HFT) Recording Sym(4), no fusion
(HFT) The candidate Sym(36) cannot be fused with the existing FusedSet(shape = Sym(0), indexSym = Sym(1), loopSyms = List(Sym(4))) because the candidate set depends on Sym(4)
(HFT) Recording Sym(36), no fusion
(HFT) The candidate Sym(39) cannot be fused with the existing FusedSet(shape = Sym(0), indexSym = Sym(1), loopSyms = List(Sym(4))) because the candidate set depends on Sym(4)
(HFT) Fusing Sym(39) with fusion set FusedSet(shape = Sym(0), indexSym = Sym(7), loopSyms = List(Sym(36)))
(HFT) - remapping index: Sym(17) -> Sym(7)
(HFT) - new loop symbol: Sym(39) -> Sym(54)
(HFT) Recording Sym(46), no fusion

(HFT) all horizontally fused: List(Sym(36), Sym(54))

-- after horizontal transformation
val x4 = new Array[Int](x0)
for (x1 <- 0 until x0) {
val x2 = x1 + 1
x4(x1) = x2
}
val x5 = x4.apply(0)
var x36 = new ArrayBuilder[Int]
for (x7 <- 0 until x0) {
val x8 = x4.apply(x7)
val x9 = x8 > 0
if (x9) {
val x10 = x8 + x5
x36 += x10
}
}
val x37 = x36.apply(0)
val x50 = println(x37)
var x54 = new ArrayBuilder[Int]
for (x7 <- 0 until x0) {
val x8 = x4.apply(x7)
val x10 = x8 + x5
val x51 = x10 > 0
if (x51) {
x54 += x7
}
}
val x55 = x54.apply(0)
val x56 = println(x55)
val x42 = x36.length
val x46 = new Array[Int](x42)
for (x28 <- 0 until x42) {
val x43 = x36.apply(x28)
val x44 = x43 + x28
x46(x28) = x44
}
val x47 = x46.apply(0)
val x57 = println(x47)

-- fusion
(FTO) Fusing these loops into one fat TTP: 
TTP(List(Sym(36)),List(SimpleLoop(Sym(0),Sym(7),MultiArrayElem(Block(Sym(13))))),SimpleFatLoop(Sym(0),Sym(7),List(MultiArrayElem(Block(Sym(13))))))
TTP(List(Sym(54)),List(SimpleLoop(Sym(0),Sym(7),MultiArrayElem(Block(Sym(53))))),SimpleFatLoop(Sym(0),Sym(7),List(MultiArrayElem(Block(Sym(53))))))

val x4 = new Array[Int](x0)
for (x1 <- 0 until x0) {
val x2 = x1 + 1
x4(x1) = x2
}
val x5 = x4.apply(0)
var x36 = new ArrayBuilder[Int]
var x54 = new ArrayBuilder[Int]
for (x7 <- 0 until x0) {
val x8 = x4.apply(x7)
val x9 = x8 > 0
val x10 = x8 + x5
if (x9) {
x36 += x10
}
val x51 = x10 > 0
if (x51) {
x54 += x7
}
}
val x37 = x36.apply(0)
val x50 = println(x37)
val x55 = x54.apply(0)
val x56 = println(x55)
val x42 = x36.length
val x46 = new Array[Int](x42)
for (x28 <- 0 until x42) {
val x43 = x36.apply(x28)
val x44 = x43 + x28
x46(x28) = x44
}
val x47 = x46.apply(0)
val x57 = println(x47)
-- done
