-- full graph
TP(Sym(2),IntPlus(Sym(1),Const(1)))
TP(Sym(3),SingletonInLoop(Block(Sym(2)),Sym(1)))
TP(Sym(4),SimpleLoop(Const(100),Sym(1),MultiArrayElem(Block(Sym(3)))))
TP(Sym(6),Reflect(Print(Sym(5)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(7),ArrayIndex(Sym(4),Sym(5)))
TP(Sym(8),IntPlus(Sym(7),Const(2)))
TP(Sym(9),Reify(Sym(8),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(6))))
TP(Sym(10),Reflect(SingletonInLoop(Block(Sym(9)),Sym(5)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(11),Reify(Sym(10),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(10))))
TP(Sym(12),Reflect(SimpleLoop(Const(100),Sym(5),MultiArrayElem(Block(Sym(11)))),Summary(true,false,false,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(14),Reflect(Print(Sym(13)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(12))))
TP(Sym(15),ArrayIndex(Sym(4),Sym(13)))
TP(Sym(16),IntPlus(Sym(15),Const(3)))
TP(Sym(17),Reify(Sym(16),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(14))))
TP(Sym(18),Reflect(SingletonInLoop(Block(Sym(17)),Sym(13)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(12))))
TP(Sym(19),Reify(Sym(18),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(18))))
TP(Sym(20),Reflect(SimpleLoop(Const(100),Sym(13),MultiArrayElem(Block(Sym(19)))),Summary(true,false,false,false,false,false,List(),List(),List(),List()),List(Sym(12))))
TP(Sym(21),ArrayLength(Sym(4)))
TP(Sym(23),Reflect(Print(Sym(22)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(20))))
TP(Sym(24),ArrayIndex(Sym(4),Sym(22)))
TP(Sym(25),IntPlus(Sym(24),Const(4)))
TP(Sym(26),Reify(Sym(25),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(23))))
TP(Sym(27),Reflect(SingletonInLoop(Block(Sym(26)),Sym(22)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(20))))
TP(Sym(28),Reify(Sym(27),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(27))))
TP(Sym(29),Reflect(SimpleLoop(Sym(21),Sym(22),MultiArrayElem(Block(Sym(28)))),Summary(true,false,false,false,false,false,List(),List(),List(),List()),List(Sym(20))))
TP(Sym(30),ArrayIndex(Sym(12),Const(0)))
TP(Sym(31),Reflect(Print(Sym(30)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(29))))
TP(Sym(32),ArrayIndex(Sym(20),Const(0)))
TP(Sym(33),Reflect(Print(Sym(32)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(31))))
TP(Sym(34),ArrayIndex(Sym(29),Const(0)))
TP(Sym(35),Reflect(Print(Sym(34)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(33))))
TP(Sym(36),Reify(Sym(35),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(12), Sym(20), Sym(29), Sym(31), Sym(33), Sym(35))))

-- before transformation
val x4 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x2 = x1 + 1
x4(x1) = x2
}
val x12 = new Array[Int](100)
for (x5 <- 0 until 100) {
val x6 = println(x5)
val x7 = x4.apply(x5)
val x8 = x7 + 2
x12(x5) = x8
}
val x20 = new Array[Int](100)
for (x13 <- 0 until 100) {
val x14 = println(x13)
val x15 = x4.apply(x13)
val x16 = x15 + 3
x20(x13) = x16
}
val x21 = x4.length
val x29 = new Array[Int](x21)
for (x22 <- 0 until x21) {
val x23 = println(x22)
val x24 = x4.apply(x22)
val x25 = x24 + 4
x29(x22) = x25
}
val x30 = x12.apply(0)
val x31 = println(x30)
val x32 = x20.apply(0)
val x33 = println(x32)
val x34 = x29.apply(0)
val x35 = println(x34)

-- vertical transformation

(VFT) No producers found for cons Sym(4)

(VFT) Fusing prod Sym(4) with cons Sym(12). Type: Mc_McForlike(Sym(5),Sym(1),Const(100),Const(100),Single_MC(Sym(5),(Sym(4),Sym(5)),Sym(2),Sym(11),Sym(3),Sym(12)),Sym(11),Sym(3),Sym(4),Sym(12))
(VFT) Fused prod Sym(4) with cons Sym(12), fused sym: Sym(42)

(VFT) Not fused prod Sym(4) with cons Sym(20) because consumer depends on producer through Sym(42)
(VFT) No producers found for cons Sym(20)
(VFT) Cons Sym(20) not fused but mirrored to Sym(49) because of fixed shape
(VFT) Replaced TP(Sym(21),ArrayLength(Sym(4))) with fixed length: Const(100)

(VFT) Not fused prod Sym(4) with cons Sym(29) because consumer depends on producer through Sym(42)
(VFT) No producers found for cons Sym(29)
(VFT) Cons Sym(29) not fused but mirrored to Sym(55) because of fixed shape

(VFT) all vertically fused: List(Sym(42), Sym(4))

-- after vertical transformation
val x42 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x2 = x1 + 1
val x37 = x2 + 2
val x38 = println(x1)
x42(x1) = x37
}
val x4 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x2 = x1 + 1
x4(x1) = x2
}
val x49 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x43 = x4.apply(x1)
val x44 = x43 + 3
val x45 = println(x1)
x49(x1) = x44
}
val x55 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x43 = x4.apply(x1)
val x50 = x43 + 4
val x51 = println(x1)
x55(x1) = x50
}
val x56 = x42.apply(0)
val x57 = println(x56)
val x58 = x49.apply(0)
val x59 = println(x58)
val x60 = x55.apply(0)
val x61 = println(x60)

-- horizontal transformation
(HFT) Recording Sym(42), no fusion
(HFT) - new loop symbol: Sym(42) -> Sym(67)
(HFT) Fusing Sym(4) with containing fusion set FusedSet(shape = Const(100), indexSym = Sym(1), loopSyms = List(Sym(42), Sym(4)))
(HFT) - already using same index Sym(1)
(HFT) The candidate Sym(49) cannot be fused with the existing FusedSet(shape = Const(100), indexSym = Sym(1), loopSyms = List(Sym(42), Sym(4))) because the candidate set depends on Sym(42)
(HFT) Recording Sym(49), no fusion
(HFT) - new loop symbol: Sym(49) -> Sym(72)
(HFT) The candidate Sym(55) cannot be fused with the existing FusedSet(shape = Const(100), indexSym = Sym(1), loopSyms = List(Sym(49))) because the candidate set depends on Sym(49)
(HFT) The candidate Sym(55) cannot be fused with the existing FusedSet(shape = Const(100), indexSym = Sym(1), loopSyms = List(Sym(42), Sym(4))) because the candidate set depends on Sym(4)
(HFT) Recording Sym(55), no fusion
(HFT) - new loop symbol: Sym(55) -> Sym(77)

(HFT) all horizontally fused: List(Sym(67), Sym(4))

-- after horizontal transformation
val x67 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x2 = x1 + 1
val x37 = x2 + 2
val x63 = println(x1)
x67(x1) = x37
}
val x4 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x2 = x1 + 1
x4(x1) = x2
}
val x72 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x43 = x4.apply(x1)
val x44 = x43 + 3
val x68 = println(x1)
x72(x1) = x44
}
val x77 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x43 = x4.apply(x1)
val x50 = x43 + 4
val x73 = println(x1)
x77(x1) = x50
}
val x78 = x67.apply(0)
val x79 = println(x78)
val x80 = x72.apply(0)
val x81 = println(x80)
val x82 = x77.apply(0)
val x83 = println(x82)

-- fusion
(FTO) Fusing these loops into one fat TTP: 
TTP(List(Sym(67)),List(Reflect(SimpleLoop(Const(100),Sym(1),MultiArrayElem(Block(Sym(66)))),Summary(true,false,false,false,false,false,List(),List(),List(),List()),List())),SimpleFatLoop(Const(100),Sym(1),List(MultiArrayElem(Block(Sym(66))))))
TTP(List(Sym(4)),List(SimpleLoop(Const(100),Sym(1),MultiArrayElem(Block(Sym(3))))),SimpleFatLoop(Const(100),Sym(1),List(MultiArrayElem(Block(Sym(3))))))

val x67 = new Array[Int](100)
val x4 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x2 = x1 + 1
val x37 = x2 + 2
val x63 = println(x1)
x67(x1) = x37
x4(x1) = x2
}
val x72 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x43 = x4.apply(x1)
val x44 = x43 + 3
val x68 = println(x1)
x72(x1) = x44
}
val x77 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x43 = x4.apply(x1)
val x50 = x43 + 4
val x73 = println(x1)
x77(x1) = x50
}
val x78 = x67.apply(0)
val x79 = println(x78)
val x80 = x72.apply(0)
val x81 = println(x80)
val x82 = x77.apply(0)
val x83 = println(x82)
-- done
