-- full graph
TP(Sym(2),IntPlus(Sym(1),Const(1)))
TP(Sym(3),SimpleLoop(Const(100),Sym(1),ArrayElem(Block(Sym(2)))))
TP(Sym(4),Reflect(NewVar(Const(0)),Summary(false,false,false,false,true,false,List(),List(),List(),List()),List()))
TP(Sym(6),Reflect(VarPlusEquals(Variable(Sym(4)),Sym(5)),Summary(false,false,false,false,false,false,List(Sym(4)),List(Sym(4)),List(Sym(4)),List(Sym(4))),List(Sym(4))))
TP(Sym(7),IntPlus(Sym(5),Const(2)))
TP(Sym(8),Reify(Sym(7),Summary(false,false,false,false,false,false,List(Sym(4)),List(Sym(4)),List(Sym(4)),List(Sym(4))),List(Sym(6))))
TP(Sym(9),Reflect(SimpleLoop(Const(100),Sym(5),ArrayElem(Block(Sym(8)))),Summary(false,false,false,false,false,false,List(Sym(4)),List(),List(Sym(4)),List()),List(Sym(4))))
TP(Sym(10),ArrayLength(Sym(3)))
TP(Sym(12),ArrayIndex(Sym(3),Sym(11)))
TP(Sym(13),Reflect(Print(Sym(12)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(14),IntPlus(Sym(11),Const(3)))
TP(Sym(15),Reify(Sym(14),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(13))))
TP(Sym(16),Reflect(SimpleLoop(Sym(10),Sym(11),ArrayElem(Block(Sym(15)))),Summary(true,false,false,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(17),ArrayIndex(Sym(3),Const(0)))
TP(Sym(18),Reflect(Print(Sym(17)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(16))))
TP(Sym(19),ArrayIndex(Sym(9),Const(0)))
TP(Sym(20),Reflect(Print(Sym(19)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(18))))
TP(Sym(21),ArrayIndex(Sym(16),Const(0)))
TP(Sym(22),Reflect(Print(Sym(21)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(20))))
TP(Sym(23),Reify(Sym(22),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(4), Sym(9), Sym(16), Sym(18), Sym(20), Sym(22))))

-- before transformation
var x4: Int = 0
var x9 = new Array[Int](100)
for (x5 <- 0 until 100) {
val x6 = x4 += x5
val x7 = x5 + 2
x9(x5) = x7
}
var x3 = new Array[Int](100)
for (x1 <- 0 until 100) {
val x2 = x1 + 1
x3(x1) = x2
}
val x10 = x3.length
var x16 = new Array[Int](x10)
for (x11 <- 0 until x10) {
val x12 = x3.apply(x11)
val x13 = println(x12)
val x14 = x11 + 3
x16(x11) = x14
}
val x17 = x3.apply(0)
val x18 = println(x17)
val x19 = x9.apply(0)
val x20 = println(x19)
val x21 = x16.apply(0)
val x22 = println(x21)

-- vertical transformation

(VFT) No producers found for TP(Sym(9),Reflect(SimpleLoop(Const(100),Sym(5),ArrayElem(Block(Sym(8)))), ...)), changed to Sym(27) because of existing substitutions or to reflect effects

(VFT) No producers found for TP(Sym(3),SimpleLoop(Const(100),Sym(1),ArrayElem(Block(Sym(2))))), remapping to Sym(29) because of fixed shape
(VFT) Replaced TP(Sym(10),ArrayLength(Sym(3))) with fixed length: Const(100)

(VFT) Fusing consumer TP(Sym(16),Reflect(SimpleLoop(Sym(10),Sym(11),ArrayElem(Block(Sym(15)))), ...)) with real producer: Sym(29) (was Sym(3))
(VFT) Combined effect of fused loop is: (Summary(true,false,false,false,false,false,List(),List(),List(),List()),List())
(VFT) General fusion: remap index to Sym(5), SimpleIndex to Sym(28).
(VFT) SimpleCollect+Any fusion: nothing more to do.

(VFT) Finished fusion of prod: Sym(29) and cons: Sym(16), the resulting fused loop is Sym(33)

(VFT) all vertically fused: List(Sym(29), Sym(33))

-- after vertical transformation
var x24: Int = 0
var x27 = new Array[Int](100)
for (x5 <- 0 until 100) {
val x7 = x5 + 2
val x25 = x24 += x5
x27(x5) = x7
}
var x33 = new Array[Int](100)
for (x5 <- 0 until 100) {
val x28 = x5 + 1
val x30 = println(x28)
val x31 = x5 + 3
x33(x5) = x31
}
var x29 = new Array[Int](100)
for (x5 <- 0 until 100) {
val x28 = x5 + 1
x29(x5) = x28
}
val x34 = x29.apply(0)
val x35 = println(x34)
val x36 = x27.apply(0)
val x37 = println(x36)
val x38 = x33.apply(0)
val x39 = println(x38)

-- horizontal transformation
(HFT) Recording Sym(27), no fusion
(HFT) - new loop symbol: Sym(27) -> Sym(44)
(HFT) The candidate Sym(33) and its set (List(Sym(29), Sym(33))) cannot be fused with the existing FusedSet(shape = Const(100), indexSym = Sym(5), loopSyms = List(Sym(27))) because both are effectful.
(HFT) Recording Sym(33), no fusion
(HFT) - new loop symbol: Sym(33) -> Sym(47)
(HFT) Fusing Sym(29) with containing fusion set FusedSet(shape = Const(100), indexSym = Sym(5), loopSyms = List(Sym(29), Sym(33)))
(HFT) - already using same index Sym(5)

(HFT) all horizontally fused: List(Sym(47), Sym(29))

-- after horizontal transformation
var x41: Int = 0
var x44 = new Array[Int](100)
for (x5 <- 0 until 100) {
val x7 = x5 + 2
val x42 = x41 += x5
x44(x5) = x7
}
var x47 = new Array[Int](100)
for (x5 <- 0 until 100) {
val x31 = x5 + 3
val x28 = x5 + 1
val x45 = println(x28)
x47(x5) = x31
}
var x29 = new Array[Int](100)
for (x5 <- 0 until 100) {
val x28 = x5 + 1
x29(x5) = x28
}
val x34 = x29.apply(0)
val x48 = println(x34)
val x49 = x44.apply(0)
val x50 = println(x49)
val x51 = x47.apply(0)
val x52 = println(x51)

-- fusion
(FTO) Fusing these loops into one fat TTP: 
TTP(List(Sym(47)),List(Reflect(SimpleLoop(Const(100),Sym(5),ArrayElem(Block(Sym(46)))),Summary(true,false,false,false,false,false,List(),List(),List(),List()),List())),SimpleFatLoop(Const(100),Sym(5),List(ArrayElem(Block(Sym(46))))))
TTP(List(Sym(29)),List(SimpleLoop(Const(100),Sym(5),ArrayElem(Block(Sym(28))))),SimpleFatLoop(Const(100),Sym(5),List(ArrayElem(Block(Sym(28))))))

var x47 = new Array[Int](100)
var x29 = new Array[Int](100)
for (x5 <- 0 until 100) {
val x28 = x5 + 1
val x31 = x5 + 3
val x45 = println(x28)
x47(x5) = x31
x29(x5) = x28
}
var x41: Int = 0
var x44 = new Array[Int](100)
for (x5 <- 0 until 100) {
val x7 = x5 + 2
val x42 = x41 += x5
x44(x5) = x7
}
val x34 = x29.apply(0)
val x48 = println(x34)
val x49 = x44.apply(0)
val x50 = println(x49)
val x51 = x47.apply(0)
val x52 = println(x51)
-- done
